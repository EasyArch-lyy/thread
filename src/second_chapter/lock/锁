悲观锁： 依靠锁机制（认为数据容易被其他线程修改，处理前加锁）
乐观锁： 表内添加version字段或业务状态实现（认为数据一般情况不会冲突，更新时对数据冲突与否进行检测）

公平锁： 表示线程获取锁的顺序是按照线程请求锁的时间早晚来决定的，早请求锁的早获取
非公平锁：先来不一定先得
ReentrantLock提供了公平和非公平两种实现,默认非公平锁
ReentrantLock pairLock =new ReentrantLock(true/false);

独占锁：锁能被单个线程持有(属于悲观锁)
共享锁：锁能被多个线程持有(属于乐观锁)
ReadWriteLock 读共享写排他

可重入锁：那么当一个线程再次获取它自己己经获取的锁时不被阻塞，该锁是可重入的，该线程获取了该锁，
那么可以无限次数地进入被该锁锁住的代码

自旋锁：当前线程在获取锁时，如果发现锁已经被其他线程占有，不马上阻塞自己，
在不放弃CPU使用权的情况下，多次尝试获取（默认次数是 10 ，可以使用-XX:PreBlockSpinsh数设置该值），
很有可能在后面几次尝试中其他线程释放了锁。如果尝试指定的次数后仍没有获取到锁则当前线程才会被阻塞挂起
自旋锁是使用CPU时间换取线程阻塞与调度的开销
