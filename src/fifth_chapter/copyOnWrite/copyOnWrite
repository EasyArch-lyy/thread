CopyOnWriteArrayList
初始化：
    无参:  内部创建大小为0的Object数组作初始值
    public CopyOnWriteArrayList(){
        setArray(new Object[0]);
    }
    有参:
    //将入参集合里面的元素复制到list
    public CopyOnWriteArrayList(E[] toCopyIn){
        Object[] elements;
    }
添加元素：
    获取独占锁 --> 获取array  --> 复制array到新数组，添加元素到新数组
    --> 新数组代替当前数组 --> 释放独占锁

获取指定位置上的元素：
    获取array数组  --> 通过下标访问指定位置元素  (过程中没有加锁同步)
  两个过程都没有加锁，于是两个过程之间另一个线程获取了锁，进行写时复制，最后array指向了复制的数组，
  array原数组引用计数器还是1，之前线程还在使用它，所以之前线程继续，得到旧array结果

修改指定元素：
    获取独占锁 --> 获取当前数组 --> 调用get获取指定位置元素
    (若指定位置元素与新值不一致则创建新数组并复制元素，新数组修改指定位置元素值并设置新数组array)
    --> (若指定位置与新值一致，为了保证volatile语义，重新设置array)

删除元素：
    获取独占锁 --> 获取数组-->获取指定元素-->(删除最后一个元素)数组长度-1
                                     -->(删除中间元素)分两次复制剩余元素到新数组   -->代替老数组释放锁
迭代器的弱一致性：
    其他线程对迭代器的修改对迭代器是不可见的，迭代器使用了数组的快照
